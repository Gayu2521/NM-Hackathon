# -*- coding: utf-8 -*-
"""colors_detector.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ixa7uiIIzY61I5Jj2Se-L7rxVGVbbeVk
"""

import streamlit as st
import numpy as np
import pandas as pd
from typing import Tuple, List, Optional

# Load color data from CSV (replace with your actual CSV file)
try:
    color_df = pd.read_csv("colors.csv")
    COLOR_NAMES = color_df['color_name'].tolist()
    HEX_VALUES = color_df['hex'].tolist()
    R_VALUES = color_df['R'].tolist()
    G_VALUES = color_df['G'].tolist()
    B_VALUES = color_df['B'].tolist()
except FileNotFoundError:
    st.error("Error: 'colors.csv' not found. Please make sure the file is in the same directory.")
    # Define a minimal color dataset as a fallback
    COLOR_NAMES = ['Red', 'Green', 'Blue']
    HEX_VALUES = ['#FF0000', '#00FF00', '#0000FF']
    R_VALUES = [255, 0, 0]
    G_VALUES = [0, 255, 0]
    B_VALUES = [0, 0, 255]
    color_df = pd.DataFrame({
        'color_name': COLOR_NAMES,
        'hex': HEX_VALUES,
        'R': R_VALUES,
        'G': G_VALUES,
        'B': B_VALUES
    })

def hex_to_rgb(hex_color: str) -> Tuple[int, int, int]:
    """
    Converts a hex color code to its RGB representation.

    Args:
        hex_color: The hex color code (e.g., "#FF0000").

    Returns:
        A tuple containing the RGB values (e.g., (255, 0, 0)).
    """
    hex_color = hex_color.lstrip('#')
    return tuple(int(hex_color[i:i + 2], 16) for i in (0, 2, 4))

def get_color_name(r: int, g: int, b: int) -> Optional[str]:
    """
    Finds the closest color name from the dataset to the given RGB values.

    Args:
        r: The red component of the color.
        g: The green component of the color.
        b: The blue component of the color.

    Returns:
        The name of the closest color, or None if no match is found.
    """
    min_distance = float('inf')
    closest_color_name = None

    for i in range(len(COLOR_NAMES)):
        distance = np.sqrt((r - R_VALUES[i]) ** 2 + (g - G_VALUES[i]) ** 2 + (b - B_VALUES[i]) ** 2)
        if distance < min_distance:
            min_distance = distance
            closest_color_name = COLOR_NAMES[i]

    return closest_color_name

def detect_color(img: np.ndarray, x: int, y: int) -> Tuple[Optional[str], Tuple[int, int, int]]:
    """
    Detects the color at the given coordinates in the image.

    Args:
        img: The image as a NumPy array.
        x: The x-coordinate of the pixel.
        y: The y-coordinate of the pixel.

    Returns:
        A tuple containing the color name and the RGB tuple.
        Returns (None, (0,0,0)) if there is an error.
    """
    try:
        b, g, r = map(int, img[y, x])  # OpenCV uses BGR
        color_name = get_color_name(r, g, b)
        return color_name, (r, g, b)
    except IndexError:
        st.error("Error: Clicked coordinates are outside the image bounds.")
        return None, (0, 0, 0)  # Return a default black color

def main():
    """
    Main function to run the color detection application using Streamlit.
    """
    st.title("Color Detection App")

    uploaded_file = st.file_uploader("Upload an image", type=["png", "jpg", "jpeg"])

    if uploaded_file is not None:
        try:
            file_bytes = np.asarray(bytearray(uploaded_file.read()), dtype=np.uint8)
            img = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)
            # Display the image using Streamlit
            st.image(img, channels="BGR", use_column_width=True)  # Display as BGR

            # Get image dimensions for coordinate scaling
            height, width = img.shape[:2]

            # Get click coordinates using Streamlit's image click handler.
            # scale factor is used to map the clicked coordinates on the displayed image
            # to the original image coordinates.
            clicked_x = st.session_state.get("clicked_x")
            clicked_y = st.session_state.get("clicked_y")
            if clicked_x is not None and clicked_y is not None:

                color_name, (r, g, b) = detect_color(img, int(clicked_x), int(clicked_y))

                st.write(f"Clicked at: x={clicked_x}, y={clicked_y}")
                if color_name:
                    st.subheader(f"Detected Color: {color_name}")
                    st.write(f"RGB: ({r}, {g}, {b})")
                    # Display color preview
                    st.markdown(
                        f'<div style="background-color: rgb({r},{g},{b}); padding: 20px; border-radius: 5px; margin-top: 10px;"></div>',
                        unsafe_allow_html=True,
                    )
                else:
                    st.subheader("No color detected")
                    st.write("Click on the image to detect the color.")
            # Create a Streamlit empty container to display click coordinates
            # The container will be updated when the user clicks on the image.
            placeholder = st.empty()

             # Use Streamlit's image click handler.
            def handle_image_click(x: float, y: float):
                # store the clicked coordinates in the session state.
                st.session_state["clicked_x"] = x
                st.session_state["clicked_y"] = y
                # Force a rerun of the script to update the output
                st.experimental_rerun()

            st.image(
                img,
                caption="Click on the image to detect color",
                channels="BGR",  # Important:  Tell Streamlit to treat the data as BGR.
                use_column_width=True,
                # set a key
                key="color_image",
                on_click=handle_image_click,  # Set the click handler
            )

        except Exception as e:
            st.error(f"Error processing image: {e}")
    else:
        st.write("Please upload an image to detect the color.")



if __name__ == "__main__":
    main()
